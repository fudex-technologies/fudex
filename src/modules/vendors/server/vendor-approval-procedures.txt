// ========================================
// VENDOR APPROVAL PROCEDURES
// ========================================

// Submit vendor for approval (vendor completes onboarding)
submitForApproval: vendorProcedure
    .mutation(async ({ ctx }) => {
        const userId = ctx.user!.id;

        const vendor = await ctx.prisma.vendor.findFirst({
            where: { ownerId: userId }
        });

        if (!vendor) {
            throw new TRPCError({
                code: 'NOT_FOUND',
                message: 'VENDOR_NOT_FOUND'
            });
        }

        if (vendor.submittedForApproval) {
            throw new TRPCError({
                code: 'BAD_REQUEST',
                message: 'ALREADY_SUBMITTED'
            });
        }

        // Update vendor as submitted
        const updated = await ctx.prisma.vendor.update({
            where: { id: vendor.id },
            data: {
                submittedForApproval: true,
                submittedAt: new Date(),
            }
        });

        // Send confirmation email to vendor
        try {
            await sendVendorSubmissionConfirmation(
                vendor.email || ctx.user!.email,
                vendor.name,
                process.env.FUDEX_ONBOARDING_EMAIL as string
            );
        } catch (e) {
            console.error('Failed to send submission confirmation email:', e);
        }

        // Notify admin
        try {
            const adminEmail = process.env.ADMIN_NOTIFICATION_EMAIL;
            if (adminEmail) {
                await sendAdminNewVendorNotification(
                    adminEmail,
                    vendor.name,
                    vendor.email || ctx.user!.email,
                    process.env.FUDEX_ONBOARDING_EMAIL as string
                );
            }
        } catch (e) {
            console.error('Failed to send admin notification email:', e);
        }

        return { success: true, message: 'Submitted for approval' };
    }),

// Upload verification document
uploadVerificationDocument: vendorProcedure
    .input(z.object({
        documentUrl: z.string().url(),
    }))
    .mutation(async ({ ctx, input }) => {
        const userId = ctx.user!.id;

        const vendor = await ctx.prisma.vendor.findFirst({
            where: { ownerId: userId }
        });

        if (!vendor) {
            throw new TRPCError({
                code: 'NOT_FOUND',
                message: 'VENDOR_NOT_FOUND'
            });
        }

        // Add document URL to array
        const updated = await ctx.prisma.vendor.update({
            where: { id: vendor.id },
            data: {
                verificationDocuments: {
                    push: input.documentUrl
                }
            }
        });

        return { success: true, documentCount: updated.verificationDocuments.length };
    }),

// Get pending vendors (admin only)
getPendingVendors: adminProcedure
    .input(z.object({
        limit: z.number().min(1).max(50).default(20),
        cursor: z.number().default(0),
    }))
    .query(async ({ ctx, input }) => {
        const skip = input.cursor;
        const limit = input.limit;

        const vendors = await ctx.prisma.vendor.findMany({
            where: {
                approvalStatus: 'PENDING',
                submittedForApproval: true,
            },
            take: limit + 1,
            skip,
            orderBy: {
                submittedAt: 'desc'
            },
            include: {
                owner: {
                    select: {
                        id: true,
                        email: true,
                        name: true,
                        firstName: true,
                        lastName: true,
                    }
                }
            }
        });

        let nextCursor: number | undefined = undefined;
        if (vendors.length > limit) {
            vendors.pop();
            nextCursor = skip + limit;
        }

        return {
            vendors,
            nextCursor,
        };
    }),

// Get vendor details for approval review (admin only)
getVendorApprovalDetails: adminProcedure
    .input(z.object({ vendorId: z.string() }))
    .query(async ({ ctx, input }) => {
        const vendor = await ctx.prisma.vendor.findUnique({
            where: { id: input.vendorId },
            include: {
                owner: {
                    select: {
                        id: true,
                        email: true,
                        name: true,
                        firstName: true,
                        lastName: true,
                        phone: true,
                        emailVerified: true,
                        phoneVerified: true,
                    }
                },
                openingHours: true,
                _count: {
                    select: {
                        productItems: true,
                    }
                }
            }
        });

        if (!vendor) {
            throw new TRPCError({
                code: 'NOT_FOUND',
                message: 'VENDOR_NOT_FOUND'
            });
        }

        return vendor;
    }),

// Approve vendor (admin only)
approveVendor: adminProcedure
    .input(z.object({ vendorId: z.string() }))
    .mutation(async ({ ctx, input }) => {
        const adminId = ctx.user!.id;

        const vendor = await ctx.prisma.vendor.findUnique({
            where: { id: input.vendorId },
            include: {
                owner: true
            }
        });

        if (!vendor) {
            throw new TRPCError({
                code: 'NOT_FOUND',
                message: 'VENDOR_NOT_FOUND'
            });
        }

        if (vendor.approvalStatus === 'APPROVED') {
            throw new TRPCError({
                code: 'BAD_REQUEST',
                message: 'ALREADY_APPROVED'
            });
        }

        // Update vendor status to approved
        const updated = await ctx.prisma.vendor.update({
            where: { id: input.vendorId },
            data: {
                approvalStatus: 'APPROVED',
                approvalDate: new Date(),
                approvedById: adminId,
                declineReason: null, // Clear any previous decline reason
            }
        });

        // Send approval email
        try {
            await sendVendorApprovalEmail(
                vendor.email || vendor.owner?.email || '',
                vendor.name,
                process.env.FUDEX_ONBOARDING_EMAIL as string
            );
        } catch (e) {
            console.error('Failed to send approval email:', e);
        }

        return { success: true, message: 'Vendor approved' };
    }),

// Decline vendor (admin only) - reason is required
declineVendor: adminProcedure
    .input(z.object({
        vendorId: z.string(),
        reason: z.string().min(10, 'Decline reason must be at least 10 characters'),
    }))
    .mutation(async ({ ctx, input }) => {
        const vendor = await ctx.prisma.vendor.findUnique({
            where: { id: input.vendorId },
            include: {
                owner: true
            }
        });

        if (!vendor) {
            throw new TRPCError({
                code: 'NOT_FOUND',
                message: 'VENDOR_NOT_FOUND'
            });
        }

        // Update vendor status to declined
        const updated = await ctx.prisma.vendor.update({
            where: { id: input.vendorId },
            data: {
                approvalStatus: 'DECLINED',
                declineReason: input.reason,
                submittedForApproval: false, // Allow resubmission
            }
        });

        // Send decline email with reason
        try {
            await sendVendorDeclineEmail(
                vendor.email || vendor.owner?.email || '',
                vendor.name,
                input.reason,
                process.env.FUDEX_ONBOARDING_EMAIL as string
            );
        } catch (e) {
            console.error('Failed to send decline email:', e);
        }

        return { success: true, message: 'Vendor declined' };
    }),
