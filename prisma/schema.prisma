generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                String             @id @default(uuid())
  name              String
  email             String             @unique
  emailVerified     Boolean            @default(false)
  image             String?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  firstName         String?
  lastName          String?
  phone             String?            @unique
  phoneVerified     Boolean            @default(false)
  referralCode      String?            @unique
  addresses         Address[]
  favoriteVendors   FavoriteVendor[]
  operator          Operator?
  orders            Order[]
  payments          Payment[]
  payoutBatches     PayoutBatch[]
  pushSubscriptions PushSubscription[]
  referredBy        Referral?          @relation("ReferredByReferrals")
  referrals         Referral[]         @relation("ReferrerReferrals")
  reviews           Review[]
  roles             UserRole[]
  approvedVendors   Vendor[]           @relation("VendorApprovedBy")
  vendors           Vendor[]           @relation("VendorOwner")
  vendorPayouts     VendorPayout[]
  accounts          Account[]
  sessions          Session[]
  packageOrders     PackageOrder[]
  packagePayments   PackagePayment[]
  wallet            Wallet?
  walletFundings    WalletFunding[]
  createdDiscounts  Discount[]         @relation("DiscountCreatedBy")

  @@map("user")
}

model UserRole {
  id         String   @id @default(uuid())
  userId     String
  role       Role
  assignedAt DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
  @@index([userId, role])
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model Area {
  id                String             @id @default(uuid())
  name              String
  state             String
  meta              Json?
  createdAt         DateTime           @default(now())
  addresses         Address[]
  deliveryFees      DeliveryFeeRule[]
  operators         Operator[]
  riderRequestItems RiderRequestItem[]
  vendors           Vendor[]           @relation("AreaVendors")

  @@unique([name, state])
  @@index([state])
}

model DeliveryFeeRule {
  id        String   @id @default(uuid())
  areaId    String
  startTime String
  endTime   String
  fee       Float
  createdAt DateTime @default(now())
  area      Area     @relation(fields: [areaId], references: [id], onDelete: Cascade)

  @@index([areaId])
}

model RiderRequest {
  id               String             @id @default(uuid())
  vendorId         String
  operatorId       String?
  assignedRiderId  String?
  status           RiderRequestStatus @default(PENDING)
  settlementStatus SettlementStatus   @default(UNSETTLED)
  totalFee         Float              @default(0)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  assignedRider    Rider?             @relation(fields: [assignedRiderId], references: [id])
  operator         Operator?          @relation(fields: [operatorId], references: [id])
  vendor           Vendor             @relation(fields: [vendorId], references: [id])
  items            RiderRequestItem[]

  @@index([vendorId])
  @@index([status])
  @@index([settlementStatus])
}

model RiderRequestItem {
  id              String       @id @default(uuid())
  riderRequestId  String
  customerName    String
  customerPhone   String
  customerAddress String
  areaId          String
  deliveryFee     Float
  createdAt       DateTime     @default(now())
  area            Area         @relation(fields: [areaId], references: [id])
  riderRequest    RiderRequest @relation(fields: [riderRequestId], references: [id], onDelete: Cascade)

  @@index([riderRequestId])
  @@index([areaId])
}

model Operator {
  id            String         @id @default(uuid())
  userId        String         @unique
  areaId        String?
  isActive      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  area          Area?          @relation(fields: [areaId], references: [id])
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders        Order[]
  riders        Rider[]
  riderRequests RiderRequest[]

  @@index([areaId])
}

model Rider {
  id            String         @id @default(uuid())
  operatorId    String?
  name          String
  phone         String?
  isActive      Boolean        @default(true)
  notes         String?
  createdAt     DateTime       @default(now())
  orders        Order[]
  operator      Operator?      @relation(fields: [operatorId], references: [id])
  riderRequests RiderRequest[]

  @@index([operatorId])
  @@index([isActive])
}

model Address {
  id         String   @id @default(uuid())
  userId     String
  label      String?
  line1      String
  line2      String?
  city       String
  state      String?
  postalCode String?
  country    String   @default("NG")
  lat        Float?
  lng        Float?
  isDefault  Boolean  @default(false)
  createdAt  DateTime @default(now())
  areaId     String?
  customArea String?
  vendorId   String?
  area       Area?    @relation(fields: [areaId], references: [id])
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendor     Vendor?  @relation(fields: [vendorId], references: [id])
  orders     Order[]

  @@index([userId])
  @@index([vendorId])
}

model Vendor {
  id                    String                       @id @default(uuid())
  ownerId               String?
  name                  String
  slug                  String                       @unique
  description           String?
  phone                 String?
  email                 String?
  coverImage            String?
  createdAt             DateTime                     @default(now())
  reviewsAverage        Float                        @default(0)
  reviewsCount          Int                          @default(0)
  bankAccountNumber     String?
  bankCode              String?
  bankName              String?
  payoutEnabled         Boolean                      @default(false)
  paystackRecipient     String?
  availabilityStatus    VendorAvailabilityStatus     @default(AUTO)
  approvalDate          DateTime?
  approvalStatus        VendorApprovalStatus         @default(PENDING)
  approvedById          String?
  declineReason         String?
  submittedAt           DateTime?
  submittedForApproval  Boolean                      @default(false)
  verificationDocuments String[]                     @default([])
  areaId                String?
  bankAccountName       String?
  addresses             Address[]
  favoritedBy           FavoriteVendor[]
  orders                Order[]
  products              Product[]
  productItems          ProductItem[]
  reviews               Review[]
  riderRequests         RiderRequest[]
  approvedBy            User?                        @relation("VendorApprovedBy", fields: [approvedById], references: [id])
  area                  Area?                        @relation("AreaVendors", fields: [areaId], references: [id])
  owner                 User?                        @relation("VendorOwner", fields: [ownerId], references: [id])
  vendorCategories      VendorCategory[]
  openingHours          VendorOpeningHour[]
  vendorPayouts         VendorPayout[]
  documents             VendorVerificationDocument[]
  discounts             Discount[]                   @relation("VendorDiscounts")

  @@index([name])
  @@index([areaId])
  @@index([name, description])
  @@index([approvalStatus])
}

model VendorVerificationDocument {
  id        String   @id @default(uuid())
  vendorId  String
  type      String
  url       String
  createdAt DateTime @default(now())
  vendor    Vendor   @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@index([vendorId])
}

model VendorOpeningHour {
  id        String    @id @default(uuid())
  vendorId  String
  day       DayOfWeek
  openTime  String?
  closeTime String?
  isClosed  Boolean   @default(false)
  vendor    Vendor    @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@unique([vendorId, day])
  @@index([vendorId])
}

model FavoriteVendor {
  id        String   @id @default(uuid())
  userId    String
  vendorId  String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendor    Vendor   @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@unique([userId, vendorId])
  @@index([userId])
  @@index([vendorId])
}

model Product {
  id          String        @id @default(uuid())
  vendorId    String
  name        String
  description String?
  createdAt   DateTime      @default(now())
  inStock     Boolean       @default(true)
  image       String?
  vendor      Vendor        @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  items       ProductItem[]

  @@index([vendorId])
}

model ProductItem {
  id          String   @id @default(uuid())
  vendorId    String
  productId   String?
  name        String
  slug        String   @unique
  description String?
  price       Float
  currency    String   @default("NGN")
  images      String[] @default([])
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  inStock     Boolean  @default(true)

  // NEW FIELDS FOR FLEXIBLE QUANTITY
  pricingType  PricingType @default(FIXED)
  unitName     String? // "scoop", "wrap", "piece", "kg"
  minQuantity  Int         @default(1)
  maxQuantity  Int? // optional limit
  quantityStep Int         @default(1) // for items sold in multiples

  // Packaging fee (only applicable for PER_UNIT items)
  packagingFee Float? // Fee per pack (e.g., â‚¦200 per container)

  orderItems         OrderItem[]
  orderItemAddons    OrderItemAddon[]
  product            Product?              @relation(fields: [productId], references: [id], onDelete: Cascade)
  vendor             Vendor                @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  categories         ProductItemCategory[]
  packageAddons      PackageAddon[]
  packageOrderAddons PackageOrderAddon[]
  discounts          Discount[]

  @@index([vendorId])
  @@index([price])
  @@index([name, description])
}

model Category {
  id               String                @id @default(uuid())
  name             String                @unique
  slug             String                @unique
  createdAt        DateTime              @default(now())
  image            String?
  arrangementIndex Int                   @default(0)
  items            ProductItemCategory[]
  vendors          VendorCategory[]

  @@index([name])
  @@index([arrangementIndex])
}

model ProductItemCategory {
  id            String      @id @default(uuid())
  productItemId String
  categoryId    String
  category      Category    @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  productItem   ProductItem @relation(fields: [productItemId], references: [id], onDelete: Cascade)

  @@unique([productItemId, categoryId])
  @@index([categoryId])
  @@index([productItemId])
}

model VendorCategory {
  id         String   @id @default(uuid())
  vendorId   String
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  vendor     Vendor   @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@unique([vendorId, categoryId])
  @@index([categoryId])
  @@index([vendorId])
}

model Review {
  id        String   @id @default(uuid())
  userId    String
  vendorId  String
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendor    Vendor   @relation(fields: [vendorId], references: [id], onDelete: Cascade)

  @@index([vendorId])
  @@index([userId])
}

model Order {
  id              String        @id @default(uuid())
  userId          String
  vendorId        String?
  addressId       String
  operatorId      String?
  assignedRiderId String?
  status          OrderStatus   @default(PENDING)
  totalAmount     Float
  currency        String        @default("NGN")
  notes           String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  deliveryFee     Float         @default(0)
  serviceFee      Float         @default(0)
  deliveryType    DeliveryType  @default(DELIVERY)
  payoutStatus    PayoutStatus  @default(NOT_ELIGIBLE)
  platformFee     Float         @default(0)
  productAmount   Float         @default(0)
  discountAmount  Float         @default(0)
  discountId      String?
  discount        Discount?     @relation("OrderDiscount", fields: [discountId], references: [id])
  address         Address       @relation(fields: [addressId], references: [id])
  assignedRider   Rider?        @relation(fields: [assignedRiderId], references: [id])
  operator        Operator?     @relation(fields: [operatorId], references: [id])
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendor          Vendor?       @relation(fields: [vendorId], references: [id])
  items           OrderItem[]
  payment         Payment?
  vendorPayout    VendorPayout?

  @@index([userId])
  @@index([vendorId])
  @@index([operatorId])
  @@index([status])
}

model OrderItem {
  id            String           @id @default(uuid())
  orderId       String
  productItemId String
  quantity      Int              @default(1)
  originalUnitPrice Float        @default(0) // Snapshot of price before discount
  discountAmount    Float        @default(0) // Amount discounted per unit
  unitPrice     Float                        // Final price after discount
  totalPrice    Float                        // quantity * unitPrice
  groupKey      String?
  order         Order            @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productItem   ProductItem      @relation(fields: [productItemId], references: [id])
  addons        OrderItemAddon[]

  @@index([orderId])
  @@index([productItemId])
}

model OrderItemAddon {
  id                 String      @id @default(uuid())
  orderItemId        String
  addonProductItemId String
  quantity           Int         @default(1)
  unitPrice          Float
  addonProductItem   ProductItem @relation(fields: [addonProductItemId], references: [id], onDelete: Cascade)
  orderItem          OrderItem   @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  @@index([orderItemId])
  @@index([addonProductItemId])
}

model Payment {
  id          String        @id @default(uuid())
  orderId     String        @unique
  userId      String
  amount      Float
  currency    String        @default("NGN")
  provider    String        @default("paystack")
  providerRef String
  status      PaymentStatus @default(PENDING)
  paidAt      DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @default(now()) @updatedAt
  metadata    Json?

  // Track if notifications have been sent to prevent duplicates
  notificationsSent   Boolean   @default(false)
  notificationsSentAt DateTime?

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([providerRef])
  @@index([status])
}

model VendorPayout {
  id           String               @id @default(uuid())
  vendorId     String
  orderId      String               @unique
  amount       Float
  currency     String               @default("NGN")
  transferRef  String?
  transferCode String?
  status       PayoutTransferStatus @default(PENDING)
  initiatedAt  DateTime             @default(now())
  completedAt  DateTime?
  batchId      String?
  userId       String?
  metadata    Json?

  batch        PayoutBatch?         @relation(fields: [batchId], references: [id])
  order        Order                @relation(fields: [orderId], references: [id])
  user         User?                @relation(fields: [userId], references: [id])
  vendor       Vendor               @relation(fields: [vendorId], references: [id])

  @@index([vendorId])
  @@index([status])
}

model PayoutBatch {
  id            String               @id @default(uuid())
  reference     String               @unique
  totalAmount   Float
  currency      String               @default("NGN")
  status        PayoutTransferStatus @default(PENDING)
  initiatedById String
  createdAt     DateTime             @default(now())
  completedAt   DateTime?
  initiatedBy   User                 @relation(fields: [initiatedById], references: [id])
  payouts       VendorPayout[]
}

model PhoneVerification {
  id        String   @id @default(uuid())
  phone     String
  otpHash   String
  expiresAt DateTime
  attempts  Int      @default(0)
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([phone])
  @@index([createdAt])
}

model Referral {
  id             String         @id @default(uuid())
  referrerUserId String
  referredUserId String         @unique
  referralCode   String
  status         ReferralStatus @default(PENDING)
  confirmedAt    DateTime?
  createdAt      DateTime       @default(now())
  referred       User           @relation("ReferredByReferrals", fields: [referredUserId], references: [id], onDelete: Cascade)
  referrer       User           @relation("ReferrerReferrals", fields: [referrerUserId], references: [id], onDelete: Cascade)

  @@index([referralCode])
  @@index([referrerUserId])
  @@index([status])
  @@index([createdAt])
  @@index([confirmedAt])
}

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model PlatformSetting {
  id    String @id @default(uuid())
  key   String @unique
  value Json
}

model playing_with_neon {
  id    Int    @id @default(autoincrement())
  name  String
  value Float? @db.Real
}

enum Role {
  CUSTOMER
  VENDOR
  OPERATOR
  RIDER
  SUPER_ADMIN
}

enum OrderStatus {
  PENDING
  PAID
  PREPARING
  ASSIGNED
  DELIVERED
  CANCELLED
  ACCEPTED
  READY
  OUT_FOR_DELIVERY
}

enum DeliveryType {
  DELIVERY
  PICKUP
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum PayoutStatus {
  NOT_ELIGIBLE
  PENDING
  PAID
  FAILED
}

enum PayoutTransferStatus {
  PENDING
  SUCCESS
  FAILED
}

enum DayOfWeek {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

enum VendorApprovalStatus {
  PENDING
  APPROVED
  DECLINED
}

enum VendorAvailabilityStatus {
  AUTO
  OPEN
  CLOSED
}

enum ReferralStatus {
  PENDING
  CONFIRMED
}

enum RiderRequestStatus {
  PENDING
  ACCEPTED
  ASSIGNED
  READY
  OUT_FOR_DELIVERY
  DELIVERED
  CANCELLED
}

enum SettlementStatus {
  UNSETTLED
  PENDING_VERIFICATION
  SETTLED
}

enum PricingType {
  FIXED // Traditional: price is for the whole item
  PER_UNIT // New: price is per unit (scoop, wrap, etc.)
}

enum DiscountType {
  PERCENTAGE
  FIXED
}

enum DiscountScope {
  PRODUCT_ITEM
  VENDOR
  PLATFORM
  CART
}

model Discount {
  id              String        @id @default(uuid())
  name            String
  description     String?

  type            DiscountType
  value           Float

  scope           DiscountScope

  productItemId   String?
  vendorId        String?

  usageLimit      Int?
  usageCount      Int           @default(0)

  startAt         DateTime
  endAt           DateTime

  isActive        Boolean       @default(true)

  createdById     String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  productItem     ProductItem?  @relation(fields: [productItemId], references: [id], onDelete: Cascade)
  vendor          Vendor?       @relation("VendorDiscounts", fields: [vendorId], references: [id], onDelete: Cascade)
  createdBy       User?         @relation("DiscountCreatedBy", fields: [createdById], references: [id])
  orders          Order[]       @relation("OrderDiscount")

  @@index([scope])
  @@index([vendorId])
  @@index([productItemId])
  @@index([startAt, endAt])
  @@index([isActive])
}

// ========== PACKAGE SYSTEM MODELS ==========
// Flexible package system for special occasions (Valentine, Christmas, etc.)

model Package {
  id             String            @id @default(uuid())
  name           String // e.g., "Valentine Packages"
  slug           String            @unique
  description    String?
  coverImage     String? // Cover image URL
  isActive       Boolean           @default(true)
  isPreorder     Boolean           @default(false) // If true, requires delivery date
  deliveryDate   DateTime? // Required if isPreorder is true
  orderCloseDate DateTime? // When orders close (e.g., Feb 13 for Valentine)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  categories     PackageCategory[]
  orders         PackageOrder[]
  items          PackageItem[]
  addons         PackageAddon[]

  @@index([slug])
  @@index([isActive])
}

model PackageAddon {
  id            String   @id @default(uuid())
  packageId     String
  productItemId String
  sortOrder     Int      @default(0)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())

  package     Package     @relation(fields: [packageId], references: [id], onDelete: Cascade)
  productItem ProductItem @relation(fields: [productItemId], references: [id])

  @@unique([packageId, productItemId])
  @@index([packageId])
  @@index([productItemId])
}

model PackageCategory {
  id          String        @id @default(uuid())
  packageId   String
  name        String // e.g., "Love Spark", "Classic", "Premium"
  slug        String // e.g., "love-spark", "classic", "premium"
  description String?
  order       Int           @default(0) // For sorting categories
  createdAt   DateTime      @default(now())
  package     Package       @relation(fields: [packageId], references: [id], onDelete: Cascade)
  items       PackageItem[]

  @@unique([packageId, slug])
  @@index([packageId])
}

model PackageItem {
  id          String   @id @default(uuid())
  packageId   String
  categoryId  String
  name        String
  slug        String
  description String?
  price       Float
  currency    String   @default("NGN")
  images      String[] @default([])
  isActive    Boolean  @default(true)
  inStock     Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Additional details for package items
  details Json? // Flexible JSON for any additional data (ingredients, sizes, etc.)

  category   PackageCategory    @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  package    Package            @relation(fields: [packageId], references: [id], onDelete: Cascade)
  orderItems PackageOrderItem[]

  @@unique([packageId, slug])
  @@index([packageId])
  @@index([categoryId])
  @@index([isActive])
}

model PackageOrder {
  id        String      @id @default(uuid())
  userId    String
  packageId String
  orderId   String? // Link to main Order table if needed
  status    OrderStatus @default(PENDING)

  // Recipient details (different from user's address)
  recipientName         String
  recipientPhone        String
  recipientAddressId    String? // Optional: can use existing address or create new
  recipientAddressLine1 String
  recipientAddressLine2 String?
  recipientCity         String
  recipientState        String?
  recipientAreaId       String?
  recipientCustomArea   String?

  // Sender details
  senderName String

  // Delivery details
  deliveryDate DateTime // The date for delivery (from package if preorder)
  timeSlot     String // e.g., "08:00-10:00", "10:00-12:00"

  // Card customization
  cardType          PackageCardType @default(CUSTOM)
  customCardMessage String? // User's custom message if cardType is CUSTOM

  // Pricing
  totalAmount   Float
  currency      String @default("NGN")
  deliveryFee   Float  @default(0)
  serviceFee    Float  @default(0)
  platformFee   Float  @default(0)
  productAmount Float  @default(0)

  // Metadata
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  package Package             @relation(fields: [packageId], references: [id])
  user    User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  items   PackageOrderItem[]
  payment PackagePayment?
  addons  PackageOrderAddon[]

  @@index([userId])
  @@index([packageId])
  @@index([status])
  @@index([deliveryDate])
}

model PackageOrderItem {
  id             String       @id @default(uuid())
  packageOrderId String
  packageItemId  String
  quantity       Int          @default(1)
  unitPrice      Float
  totalPrice     Float
  packageOrder   PackageOrder @relation(fields: [packageOrderId], references: [id], onDelete: Cascade)
  packageItem    PackageItem  @relation(fields: [packageItemId], references: [id])

  @@index([packageOrderId])
  @@index([packageItemId])
}

model PackagePayment {
  id             String        @id @default(uuid())
  packageOrderId String        @unique
  userId         String
  amount         Float
  currency       String        @default("NGN")
  provider       String        @default("paystack")
  providerRef    String
  status         PaymentStatus @default(PENDING)
  paidAt         DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  metadata       Json?

  // Track if notifications have been sent to prevent duplicates
  notificationsSent   Boolean   @default(false)
  notificationsSentAt DateTime?

  packageOrder PackageOrder @relation(fields: [packageOrderId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([providerRef])
  @@index([status])
}

model PackageOrderAddon {
  id             String @id @default(uuid())
  packageOrderId String
  productItemId  String
  quantity       Int    @default(1)
  unitPrice      Float
  totalPrice     Float
  name           String // Snapshot of name

  packageOrder PackageOrder @relation(fields: [packageOrderId], references: [id], onDelete: Cascade)
  productItem  ProductItem  @relation(fields: [productItemId], references: [id])

  @@index([packageOrderId])
  @@index([productItemId])
}

enum PackageCardType {
  ADMIN_CREATED // Admin creates the card
  CUSTOM // User customizes the card themselves
}

enum WalletTransactionType {
  CREDIT
  DEBIT
}

enum WalletTransactionSource {
  ORDER_PAYMENT
  PACKAGE_PAYMENT
  REFUND
  REFERRAL_BONUS
  WALLET_FUNDING
  ADMIN_ADJUSTMENT
}

enum WalletFundingStatus {
  PENDING
  COMPLETED
  FAILED
}

model Wallet {
  id           String              @id @default(uuid())
  userId       String              @unique
  balance      Decimal             @default(0) @db.Decimal(12, 2)
  isActive     Boolean             @default(true)
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions WalletTransaction[]

  @@map("wallet")
}

model WalletTransaction {
  id         String                  @id @default(uuid())
  walletId   String
  amount     Decimal                 @db.Decimal(12, 2)
  type       WalletTransactionType
  sourceType WalletTransactionSource
  sourceId   String? // polymorphic id
  reference  String                  @unique // for idempotency
  createdAt  DateTime                @default(now())
  wallet     Wallet                  @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([walletId])
  @@index([reference])
  @@map("wallet_transaction")
}

model WalletFunding {
  id          String              @id @default(uuid())
  userId      String
  amount      Decimal             @db.Decimal(12, 2)
  providerRef String              @unique
  status      WalletFundingStatus @default(PENDING)
  paidAt      DateTime?
  metadata    Json?
  createdAt   DateTime            @default(now())
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([providerRef])
  @@map("wallet_funding")
}
